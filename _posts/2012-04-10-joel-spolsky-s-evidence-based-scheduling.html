---
layout: page
title: 事例によるスケジューリング
date: 2012-04-10 10:43
excerpt: Joel Spolskyの記事を訳した。
image: http://local.joelonsoftware.com/mediawiki/images/1/1e/26a.jpg
---
<p><a href="http://www.joelonsoftware.com/items/2007/10/26.html">Joel Spolskyの記事</a>を訳した。方法論というより、単なるアルゴリズムの説明。<a href="http://local.joelonsoftware.com/wiki/%E4%BA%8B%E4%BE%8B%E3%81%AB%E3%82%88%E3%82%8B%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0">翻訳wiki</a>に置いたが、こちらにも転載。ミスの指摘など歓迎。</p><h2>事例によるスケジューリング</h2><p>2007年10月26日 金曜</p><p>ソフトウェア開発者はスケジュールを作りたがらない。大抵はなしですまそうとする。「出来上がったときが<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成日</abbr>さ！」と元気一杯見栄を切ってボスを喜ばせ、活気づいたままどこかにスケジュールは忘れ去られてしまう。</p><p>スケジュールがあるとしても、半端なものであることが多い。誰か一人によってしぶしぶ作られて、共有フォルダのどこかに置かれて、忘れ去られる。2年後、キャビネットの底で古びたプリントを見つけた人が反省会に持ってきてネタにするのだ。</p><p>「見ろよこれ。Rubyで1から書き直すのを2週間ですます予定だったらしい」</p><div style="float: right;"><img src="http://local.joelonsoftware.com/mediawiki/images/1/1e/26a.jpg" alt="26a.jpg" width="240" height="161" /></div><p>笑えるね。まだその真っ最中ならなおさら。</p><p>できることなら、やる価値のあるタスクだけに時間を注ぎたいだろう。しかし、一番やる価値のある仕事を決めるには、どの程度時間がかかるのか知る必要がある。「飛び跳ねる紙クリップ」機能と「金融計算関数を追加」機能のどちらに手をつけるか決めるには、それぞれにかかる時間を知らねばならない。</p><p>なぜ開発者はスケジュールを作らないのだろうか？理由は二つある。（１）作るのが面倒だ。（２）本当にそのとおりになるわけがない。正確にならないとわかっているスケジュールを誰がわざわざ作ろうとするだろう？</p><p>去年Fog Creekは、どれほど文句の多い開発者でも使いたくなるほど簡単なシステムを開発した。そして、我々の知る限り、このシステムはかなり信頼性の高い予測をしてくれる。名前は <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr>（Evidence Based Scheduling：事例をもとにしたスケジューリング）と言う。</p><p>タスクがいつ始まっていつ終わったかの<strong>事例</strong>を、タイムカードなどの記録から集める。それらからスケジュールの将来を予測する。計算の結果となるのは<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>ひとつではなく、<abbr title="confidence distribution curve">完成する確率を日付ごとに並べたグラフ</abbr>だ。</p><p>それはこういう見た目になる。</p><div><div class="thumbinner" style="border: 1px solid gray; background-color: #eee; text-align: center; width: 472px;"><p><img style="border: 1px solid gray;" src="http://local.joelonsoftware.com/mediawiki/images/9/98/20071026-1.png" alt="" width="470" height="250" /></p><div class="thumbcaption">(訳注: バーンダウン図に見えるが全く別物。</div><div class="thumbcaption">言うなれば横軸の日付でバーンダウン図が100％になる確率)</div></div></div><p>曲線が急であればあるほど、その日にリリースできると自信を持って言えることになる。</p><p>やり方を説明しよう。</p><h2>1) 粉々にする</h2><p>単位を日数や週の数で立てたスケジュールはうまくいかない事を我々はよく知っている。</p><p>タスクを小さく分けて行って、単位が<strong>時間</strong>になるまで細かく分けよう。16時間以下がいい。</p><p>分けることで、あなたがやるべきことの中身を実際に考えるように仕向けることができる。<em>foo</em> サブルーチンを書く。ダイアログボックスを作る。Fizzbottファイルをパースする。一つ一つの開発タスクにかかる時間は簡単に予想がつく。なぜなら、前にあなたは似たようなことをやったことがあるからだ。</p><p>あなたが大雑把な開発者なら、3週間程度の大きいタスクを作ることがあるだろう（「Ajax画像エディタを実装」とか）。そういう時あなたは、<em>実際にどう作業するかを考えずにすましている</em>。一つ一つの手順を詳細に想像せずに。実際何をするのかわかっていなければ、かかる時間を見積るのは不可能だ。</p><p>タスクの限度を16時間にしたのは、開発者に機能そのものを<em>デザイン</em>させるためだ。3週間で派手な「Ajax画像エディタ」を細かい設計なしに作ろうとするのは、言わせてもらえば<em>正気じゃない</em>。</p><p>どんな手順を踏んで作るのか把握せずに作ろうとしても、そのステップをいくつか踏み忘れたままで終わるだろう。</p><h2>2) 時間を記録する</h2><p>タスクにかかる時間を正確に予想するのは難しい。他の仕事が割り込んでくるかもしれない。予想もしないバグが出てきたり、ミーティングもあるだろう。Windowsが年貢の納めどきを迎えて、開発マシンを丸ごと再インストールする羽目になるかもしれない。</p><p>これらにどれだけ確保すればよいのだろう。いや、トラブルの類が全くなかったとしても、そのサブルーチンを書くのにどれだけかかるのか予想がつくだろうか？</p><p>実際のところ、不可能だ。</p><p>タイムシートをつけよう。各タスクにどれだけ時間がかかったか記録をとる。タスクが終わった後、実際かかった時間が予想とどれだけ違うか比べることができる。</p><p>その記録をグラフ上に点を打っていくと、各人にこういうグラフができあがる。</p><p><img src="http://local.joelonsoftware.com/mediawiki/images/b/bc/20071026-2.png" alt="20071026-2.png" width="369" height="376" /></p><p>点のひとつひとつは完了したタスクを表している。横の座標が予想した時間で、縦の座標が実際に完了するのにかかった時間だ。予想の時間を実際の時間で割ると、そのタスクの<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>がわかる。タスクが予想とよりどれだけ早く済んだか、という割合だ。</p><p>プロジェクトを進めながらこのグラフに点を打っていくことで、開発者ごとに<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>のレコードが溜まってゆく。</p><ul><li> <abbr title="perfect estimator"><span style="color: maroon;">完璧な開発者</span></abbr>は、実際いれば伝説に残る存在だが、想像上にしかいない。全て予想通りの時間でぴったりタスクを済ませる。<br /> つまり、<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>の記録は <tt style="font-size: 12pt;"> {1, 1, 1, 1, 1, ... } </tt> のようになる。</li><li> 典型的な、<abbr title="bad estimator"><span style="color: maroon;">予想下手な開発者</span></abbr>は、グラフ上にバラバラな点を打つ。長めに予想することもあれば、短すぎることもある。<br /> この場合の記録は、例えば <tt style="font-size: 12pt;"> {0.1, 0.5, 1.7, 0.2, 1.2, 0.9, 13.0} </tt> のようになる。</li><li> 多くの開発者はスケールを取り違えるが、相対的には概ねよい予想をする。<br /> 予想外のバグ修正やミーティング、コーヒーブレイク、うるさく心配するボスの割り込みなどがあいまって、ほとんどのタスクは予想より長くかかる。<br /> こういった<abbr title="common estimator"><span style="color: maroon;">平均的な開発者</span></abbr>は、たいてい１以下で、ぶれの少ない<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>のレコードを残す。例えば<tt style="font-size: 12pt;"> {0.6, 0.5, 0.6, 0.6, 0.5, 0.6, 0.7, 0.6} </tt> のようになる。</li></ul><p>タスクの予想は、開発者が経験を積むにつれて精度が上がってゆく。なので、古い<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>の記録、例えば６ヶ月より前のものは勘定に入れないほうがよいだろう。</p><p>チームに新しい開発者が加わった時には予想の記録がないが、その場合は下手な方で仮定しておく。広い範囲で<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>のダミーの記録を用意しておいて、6つほどタスクをすませるまではそれを計算に使う。</p><h2>3) 未来をシミュレートする</h2><p>タスクをすべてこなしたら出荷できるとすると、プロジェクトの<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>は単に全タスクの予想時間を足し合わせれば出てくる。この方法はもっともらしく見えるがうまくいかない。</p><p>代わりに <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> ではモンテカルロ法で<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>を推測する。</p><p>プロジェクトの将来のシナリオを100通りシミュレートする。ありえるシナリオのそれぞれは1%に対応する。それらの<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>を頻度表として集計すると、それぞれの日付について完成する確率のグラフができあがる。</p><p>シナリオを計算するとき、各タスクの予想時間をその開発者の<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>で割る。この<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>はステップ2で集めた履歴からランダムに選んだものだ。</p><p>たとえばある未来ではこの開発者のタスクはこうなる。</p><p><img src="http://local.joelonsoftware.com/mediawiki/images/1/1f/20071026-3.png" alt="20071026-3.png" width="487" height="94" /></p><p>これを100回繰り返そう。合計一つは1%の可能性を持つので、あなたは任意の日に出荷できる確率を知ることができる。</p><p>先ほどの開発者たちがどうなるか見てみよう：</p><ul><li> <abbr title="perfect estimator"><span style="color: maroon;">完璧な開発者</span></abbr>の場合、常に<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>は1だ。この<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>で割ってもタスクの予想時間には何の影響もない。つまり、シミュレーションは100回すべてで同じ<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>をはじき出し、その確率は100%である。まるでおとぎ話だ。</li><li> <abbr title="bad estimator"><span style="color: maroon;">予想下手な開発者</span></abbr>の場合、<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>は広く分布する。範囲は0.1から13.0までというところだろう。<br /> この中からランダムに選んで値を割るから、シミュレーションの結果は毎回大きく変動する。<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>の確率は浅く広く分布し、明日出荷できるかもしれないし、遠い未来かもしれない。とはいえ、読み取れることはある：あなたは<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>に自信を持ってはならない。</li><li> <abbr title="common estimator"><span style="color: maroon;">平均的な開発者</span></abbr>は互いによく似た<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>を持つ。<tt style="font-size: 12pt;"> {0.6, 0.5, 0.6, 0.6, 0.5, 0.6, 0.7, 0.6} </tt> のようになる。<br /> これらの中から選んで割ると、各タスクの予想時間は割り増しで計算される。8時間のタスクは13時間になるか、あるいは他では15時間になる。</li></ul><p>このように、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はあなたの楽観的な見通しを補ってくれる。予測はあなた本人による<em>実証済みの、実例の記録</em>によって、あなたの楽観さ度合いとぴったり<em>同じだけ</em>補われる。<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>が0.6の前後あたりで狭く分布するので、<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>の範囲も狭い範囲に収まる。</p><p>モンテカルロシミュレーションでは毎回、時間単位のデータをカレンダー上の単位に変換しなければならない。その差異には各開発者の出勤予定、旅行、休日の日なども考慮する必要がある。また、最後に仕事を終えるのがどの開発者か判別しなければならない。なぜなら、そのとき初めてチーム全体の仕事が終わるからだ。</p><p>こういった計算は骨が折れるが、幸いなことに、骨を折るのはコンピュータの得意とするところだ。</p><h2>強迫症になる必要はない</h2><p>この間行った釣り旅行についてボスが武勇伝を長々と語り出したらどうすればよいだろう？いても仕方がないのに経営会議に出なければならなくなったら？コーヒーブレイクは？新人のために開発環境をセットアップしてやるのに気づいたら半日使ってしまったら？</p><p>Brettと私がFog Creekでこの手法を開発している時、こういった突発的で時間を食う事に頭を悩ませていた。時にはこの種の時間の合計が開発にかけた時間を超すことすらある。</p><p>こういったことにもタスクを立てるべきだろうか？時間を予想して、タイムシートで記録をつければよいのだろうか？</p><div><div class="thumbinner" style="border: 1px solid gray; background-color: #eee; text-align: center; width: 462px;"><p><img style="border: 1px solid gray;" src="http://local.joelonsoftware.com/mediawiki/images/7/74/20071026-4.png" alt="" width="460" height="223" /></p><div class="thumbcaption">真面目につけた場合のタイムシート。 「ブログを読む」「企業ミッション委員会ミーティング」「クラスパスの問題を調査」「Eclipse 再インストール」<br /> 「就職希望者と面談」「HTMLページの背景を青にする」「コーヒーブレイク」「クラスパスの問題を調査」&hellip;</div></div></div><p>まあ、そうしたいならできないことはない。 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はそれでもうまく働く。</p><p><em>しかし、そうする必要はない。</em></p><p>実のところ、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はよく動いてくれる。何のタスクの最中にどんな仕事が舞い込んだとしても、あなたはただ<em>時計を動かしてさえいればよい</em>。不安に思うだろうが、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はそれでも良い予測を生む。</p><p>簡単な例を紹介しよう。簡単にするために、ここにジョンという平凡なプログラマがいたとする。彼の仕事はどこかの低級<em>な</em>言語の必要とする、一行のゲッターとセッターを書くというものだ。</p><blockquote style="font-family: monospace; white-space: pre-wrap; font-size: 12pt;"><p>private int width;<br /> public int getWidth () { return width; }<br /> public void setWidth (int _width) { width = _width; }</p></blockquote><p>いやいや、わかっている。あほらしい例だが、あなたはこういう奴を見たことが<em>あるはず</em>だ。</p><p>ともかく、このゲッターなりセッターなりを書くのに彼は毎回2時間かかる。従って、彼のタスクの予想時間はこのようになる：</p><blockquote style="font-family: monospace; white-space: pre-wrap; font-size: 12pt;"><p>{ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, &hellip; }</p></blockquote><div style="float: right;"><img src="http://local.joelonsoftware.com/mediawiki/images/1/10/26fish.jpg" alt="26fish.jpg" width="240" height="160" /></div><p>さて、彼は仕事中かわいそうなことに頻繁にボスに邪魔される。ボスは<span title="marlin fishing">マカジキ釣り</span>について語りだすと2時間は止まらない。</p><p>もちろんジョンは「マカジキについての退屈な雑談」と名付けたタスクをタイムシートに増やしてもいいが、この行いは政治的に適切とは言い難い。</p><p>代わりにジョンはそのとき開いていたタスクに時間をそのまま記入する。実際の経過時間の記録はこうなる。</p><blockquote style="font-family: monospace; white-space: pre-wrap; font-size: 12pt;"><p>{ 2, 2, 2, 2, <strong>4</strong>, 2, 2, 2, 2, <strong>4</strong>, 2, &hellip; }</p></blockquote><p>これを予想時間とあわせて<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>を計算すると、このようになる。</p><blockquote style="font-family: monospace; white-space: pre-wrap; font-size: 12pt;"><p>{1, 1, 1, 1, <strong>0.5</strong>, 1, 1, 1, 1, <strong>0.5</strong>, 1, &hellip; }</p></blockquote><p>モンテカルロシミュレーションにはどう影響するだろうか。予想の2時間が1でなく0.5で割られる確率は、<em>将来ボスがジョンを邪魔する確率とまったく同じになり</em>、それを真面目にタスクとして登録した場合と同じ結果になる。 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はこちらでもうまく動くのだ！</p><p>実のところ、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はタイムシートに貼り付いて真面目に記録を取る開発者よりも正確な予測をする。</p><p>人に話すとき、私はこれを次のように説明している。開発者が邪魔されたとき、彼らは&hellip;</p><ol><li> タイムシートに真顔で「邪魔された」と追加して、自分が釣り談義でいかに時間を無駄にされているか<abbr title="management">経営者</abbr>に気づいてもらえるようにするか、あるいは</li><li> 邪魔された項目を新たに作らず、その時担当するタスクに無駄にした時間を加算して、<em>俺を誘いもしなかった</em>釣りについての長話がなければ完璧に正しかったはずの自分の予想時間をそのままにしておくか</li></ol><p>&hellip;のどちらかで、あなたのチームの開発者がどちらのタイプであったにしても、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> は同じ正確な結果を出す。</p><h2>4) プロジェクトを積極的に管理する</h2><p>この手法が順調にいけば、あなたはプロジェクトを納期内に収めるために積極的に活用することができる。</p><p>例えば、各機能に優先度を振って整理しておけば、優先度の低い機能を抜きにした場合どれだけ<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>が早まるかをすぐに見てとれる。</p><div><div class="thumbinner" style="border: 1px solid gray; background-color: #eee; text-align: center; width: 299px;"><p><img style="border: 1px solid gray;" src="http://local.joelonsoftware.com/mediawiki/images/e/e5/20071026-5.png" alt="" width="297" height="180" /></p><div class="thumbcaption">タスクを優先度を下から絞込み、タスクがすべて終わる確率が50%になるのが何月になるかの表</div></div></div><p>また、開発者<em>各人</em>についての<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>の分布を見てもよい。</p><div><div class="thumbinner" style="border: 1px solid gray; background-color: #eee; text-align: center; width: 462px;"><p><img style="border: 1px solid gray;" src="http://local.joelonsoftware.com/mediawiki/images/0/07/20071026-6.png" alt="" width="460" height="238" /></p><div class="thumbcaption">横軸が年月、各行が開発者の名前で、シミュレーションによる<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>の分布を箱ひげ図で表示したもの</div></div></div><ul><li> 開発者によっては（図で言う3行目の Milton）、<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成日</abbr>の予測がほとんどつかない者もいる。そういう開発者はうまく予想するよう練習に努める必要がある。</li><li> そうでない開発者（図の4行目の Jane のような）は、<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成日</abbr>の予想範囲が狭い範囲に収まっているものの、少し遅れ気味だ。<br /> 彼女の負っているタスクをいくらか他の開発者にまわしたほうがいいだろう。</li><li> それ以外の開発者（私だ。イェーイ）はクリティカルパスにまったく関わらないので、心配ない。</li></ul><h2>スコープの動き</h2><p>あなたが詳細の詳細まで完璧に詰めてからプロジェクトにとりかかるのなら、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> はうまく働く。しかし、実際は予定にない機能をやることになるだろう。</p><p>新しいアイデアが浮かぶこともあるし、営業員が存在しない機能を約束して帰ってくるかもしれない。お偉いさんの一人がお仲間と談笑しながらゴルフ中、あなたの開発しているGPSつきゴルフカートに心電図を追加するという素晴らしいアイデアを思いつくかもしれない。</p><p>いずれにしろ、あなたのスケジュールには新たな遅延が加わる。</p><p>単純に考えれば、これらに対応するため、バッファ期間を用意すればよい。以下のようにそれぞれのバッファを用意したとする。</p><ol><li> 新機能のアイデア</li><li> <abbr title="responding to the competition">競合製品への対抗</abbr></li><li> 全員のコードをマージして統合</li><li> デバッグ</li><li> ユーザビリティテスト(とそのフィードバック)</li><li> ベータテスト</li></ol><p>すると、新機能を思いついた時は、1番のバッファを削ってそれに充てることになる。</p><p>新機能を次々追加するうちにバッファがなくなってしまったらどうなるだろうか。まあ、 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> の<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>は遠くにずれてゆくだろう。こういう状況を把握するには、毎日<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>の分布のスナップショットを取ることだ。</p><div><div class="thumbinner" style="border: 1px solid gray; background-color: #eee; text-align: center; width: 462px;"><p><img style="border: 1px solid gray;" src="http://local.joelonsoftware.com/mediawiki/images/5/5f/20071026-7.png" alt="" width="460" height="246" /></p><div class="thumbcaption"><abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>の追跡グラフ</div></div></div><p>横軸はシミュレーションのスナップショットをとった時刻で、縦軸は<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>を示す。三本の折れ線はそれぞれ次を意味する。上のは完成確率が95％の日。中央は50％。下は5％。つまり、折れ線が互いに近づくほど、<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>の範囲は狭まることになる。</p><p>もし<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">完成予想日</abbr>がどんどん遅れていっているなら（グラフが右肩上がりなら）、プロジェクトに何か問題がある。遅れ具合が1日に1日ずつでないなら、タスクをこなす<abbr title="velocity タスクの予想所要時間を実際かかった経過時間で割ったもの"><span style="color: navy;">勢い</span></abbr>よりも追加されるほうが早いので、そのプロジェクトは決して終わらない。このグラフが徐々に収束しているなら、出荷予定も定まってきていると見ていい。</p><h2>使用上の注意</h2><p>この手法を使ううち見つけた、いくつかの注意すべき点をあげる。</p><p><strong>1) 担当のプログラマだけがタスクを予想すること。</strong></p><p>どんな方法であれ、マネージャが予定を立ててそれをプログラマに渡すようなことでは必ず失敗する。その機能を実装するプログラマ本人だけが、必要な手順を見定めることができる。</p><p><strong>2) バグを見つけたらその場で修正して、その時間をバグ部分を実装したタスクに加算すること。</strong></p><p>バグは予想のつかないものなので、バグフィックスは予定してやることはできない。実装にバグを見つけたら、修正にかけた時間はその部分を実装したタスクに時間を加算するといい。単に<em>動くコード</em>の分だけでなく、<em>デバッグ済みのコード</em>が仕上がるまでの時間を記録することになるので、その分 <abbr title="事例によるスケジューリング Evidence Based Scheduling"><span style="color: green;">EBS</span></abbr> の予測が正確になる。</p><div style="float: right;"><img src="http://local.joelonsoftware.com/mediawiki/images/7/79/26b.jpg" alt="26b.jpg" width="250" height="167" /></div><p><strong>3) 予想時間が短いの長いのでマネージャに文句を言わせないこと。</strong></p><p>新米のソフトウェアマネージャによくあることだが、「<abbr title="tight">適度にきつい</abbr>」（非現実的なほど短い）スケジュールを与えることで、プログラマを「<abbr title="motivate">きりきり</abbr>」働かせることができると考えることがある。私から見ると、これは無能のやることだ。この類のモチベーションは長続きしない。</p><p>私が遅れたスケジュールのもとにあると知っても、やる気をなくして絶望し落ち込むだけだ。逆にもし予定以上に早く進んでいると知れば、生産的で活発に働いていられるだろう。スケジュールは社会心理の実験場ではない。</p><p>なぜマネージャはこういったことをしようとするのだろう？</p><p>プロジェクトが始まって技術マネージャが去り、ビジネス関係者が来て彼らが<em>検討</em>の結果３ヶ月でできるという機能リストを持ってくる。しかし、それらは実際１２ヶ月かかるのだ。</p><p>コーディング作業の手順を抜きに考えたなら、機能の実装は <tt><em>n</em></tt> 時間ですむが、現実では多くは <tt><em>4n</em></tt> 以上かかる。あなたがタスクの詳細を詰め、スケジュールを立て直すと、彼らの考えるよりプロジェクトはずっと長くかかることがわかる。経営陣は不満がるだろう。</p><p>無能なマネージャは、これを解決するため、プログラマをより早く働かせる方法を探す。これは現実的ではない。チームの人数を増やした場合、新人がコードを把握して追いつくまでに時間がかかる。その後も数ヶ月は50％程度の能率でしか働かないだろう（しかも、彼らの世話に時間をとられて既存メンバーの能率も下がる）。</p><p>この方法は<em>一時的に</em>10％増しのコード量を生むかもしれないが、それは1年で100％生むコードと引き換えのものだ。割りのいい取引とは言えない。これは種もみを食べてしまうことに少し似ている。</p><p>また、言うまでもないが、開発者たちを酷使することで、デバッグにかかる時間は<em>倍増</em>し、ただでさえ遅れているプロジェクトはさらに遅れることになる。<abbr title="Splendid karma. (まったくいい報いだ)">なんということでしょう</abbr>。</p><p>いずれにせよ、4n を n に押し込む方法は存在しない。もしできると思うのなら、あなたの会社の銘柄名を教えて欲しい。売るから。</p><p><strong>4) スケジュールは積み木箱である。</strong></p><p>積み木が沢山あって、箱のなかに収まらないときは、二つの手段がある。もっと大きい箱を持ってくるか、積み木ブロックの数を減らすかだ。</p><p>6ヶ月で出荷したいが、12ヶ月かかるとわかっているときは、出荷を延期するか、機能を選んで削るしかない。単にブロックを小さく縮めてすますことはできない。仮にできるふりをしたとしても、あなたは先を見据える機会を捨てて、目の前に見えているものを見えないと自分に嘘をついているだけだ。</p><p>機能を削る羽目になるというのは、スケジューリングの<em>いいところ</em>だ。なぜかって？</p><p>あなたが実装したい機能がふたつあるとしよう。一つは実用的で、製品を素晴らしいものにする。もう一つはとても簡単で、プログラマは作業にかかりたくてたまらない<small>（見て見て！&lt;ウインク&gt;）</small>が、製品の目的からみて特に意味はない。</p><div style="float: right;"><img src="http://local.joelonsoftware.com/mediawiki/images/4/4f/26c.jpg" alt="26c.jpg" width="240" height="161" /></div><p>スケジュールを立てずにすますなら、プログラマは間違いなく簡単で楽しいものをやろうとする。そして時間を使ってしまい、有用で重要な機能を作るために延期せざるを得なくなる。</p><p>スケジュールを作りさえすれば、実際の作業にかかる前であっても、何かの機能を削る必要があることに気づくことができる。楽しく無意味な機能は削られて、あなたの製品は有用な機能と早い<abbr title="ship date (1) ソフトウェアが実際完成する日。 (2) プロジェクトの納期。">出荷日</abbr>に恵まれることになる。</p><p>私がExcel 5に関わっていたとき、最初に作られた機能リストは巨大で、<em>とても</em>納期には収まるものではなかった。「なんてことだ！」我々は思った。「<em>一つ残らず</em>重要な機能なのに！マクロ編集ウィザードなしでどう生きていけばいいんだ？」</p><p>他に選択肢もなく、我々は「ソフトの根幹をなす」と考えていた機能をいくつか除いてスケジュールを納期に収めた。誰もが削除を残念に思った。慰めのため、我々は機能を<em>カットした</em>のではなくExcel 6に<em>延期した</em>のだと思うことにした。</p><p>Excel 5が完成に近づいた時、私は同僚のEric MichelmanとExcel 6の仕様にとりかかった。二人でまずExcel 5でカットされた機能のリストを眺めることにした。私たちは驚いた。なんだこれは。これほどクズ機能ばかり集めたリストがあっていいものか。</p><p>見直してみると、リスト中で実装する価値のあるものは<em>一つも</em>なかった。スケジュールの為に機能を絞ることは我々の一番の成功といえる。でなければ、Excel 5のスケジュールは倍に伸び、50%を占めるクズ機能が積まれ、その後永遠に後方互換性のために残ることになっていただろう。</p><h2>まとめ</h2><p>事例によるスケジューリングを使うのはとても簡単だ。各イテレーションの初めに詳しく予想を立てるのに１日２日かける。その後は毎日数秒、実際の経過時間をタイムシートに記録しながら進める。比べて得られる利益は相当なものだ。現実的なスケジュールが立つのだから。</p><p>現実的なスケジュールはよいソフトウェアを作るカギとなる。必要な機能が先に実装できるようにし、どのような物を作る判断を下す指針になる。製品はすばらしいものになり、ボスは笑顔であり、顧客は満足し、そしてなにより、あなたは5時に家に帰ることができる。</p><div class="center"><div class="floatnone"><img src="http://local.joelonsoftware.com/mediawiki/images/f/f9/26d.jpg" alt="26d.jpg" width="470" height="333" /></div></div><h2>P.S.</h2><p>事例によるスケジューリングは<a class="external text" rel="nofollow" href="http://www.fogcreek.com/FogBugz/">FogBugz 6.0</a>に組み込みの機能のひとつだ。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr />&nbsp;<p>&nbsp;</p><p>&nbsp;</p><h2>訳語</h2><dl> <dt> confidence distribution curve ： (完成する確率を日付ごとに並べたグラフ)&nbsp;</dt> <dd> 最初のグラフのこと。「この日に出荷できる確率は&times;&times;％」を図に折れ線として表したもの。 </dd> </dl> <dl> <dt> estimation history ： (予想の履歴)&nbsp;</dt> <dd> 二つ目のグラフのこと。記事中に名前は出ていない。<br /> 予想時間と経過時間をプロットしたもの。勢いは原点からの傾きになる。 </dd> </dl> <dl> <dt> estimated time ： 予想時間&nbsp;</dt> <dd> 開発者がそのタスクの作業をすますのに必要と考える時間。 </dd> </dl> <dl> <dt> estimator&nbsp;</dt> <dd> 予想をする開発者&nbsp;: 直訳すると「予想者」になるが、どちらにしても開発者本人が予想することになるので言い換えた。 </dd> </dl> <dl> <dt> elapsed time, actual hours ： 経過時間、実際の時間&nbsp;</dt> <dd> タスクが終了するまで実際にかかった時間。<br /> タスクが終わってクローズされた後もバグなどで加算されることがある。 </dd> </dl> <dl> <dt> Evidence Based Scheduling：事例によるスケジューリング&nbsp;</dt> <dd> プロジェクトの完成日を予測するための手法。モンテカルロ法を使ったアルゴリズム。記事本文を参照。 </dd> </dl> <dl> <dt> ship date： 完成日、完成予定日、出荷日、出荷予定日&nbsp;</dt> <dd> 1) ソフトウェアが実際完成する日。<br /> 2) プロジェクトを間に合わせねばならない納期。 </dd> </dl> <dl> <dt> task：タスク&nbsp;</dt> <dd> 1) ソフトウェアに機能を実装する手順を分割したうちの一ステップ。長さの単位は時間。関数を書くとか、ダイアログを作るとか。<br /> 2) 開発者に割り当てる仕事。<br /> 記事中では触れられていないが、FogBugzでは親タスクと子タスクの概念がある。 </dd> </dl> <dl> <dt> velocity ： 勢い&nbsp;</dt> <dd> 勢い ＝ 予想時間 &divide; 経過時間<br /> あるタスクが予想に対してどれだけ早く終わったかを示す割合。予想の半分で終わったら勢いは0.5になる。予想の倍かかったら勢いは2になる。 </dd> </dl>
